<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<style>
  /* â”€â”€â”€ Reset & Base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg: #1a1a2e;
    --bg-card: #16213e;
    --bg-input: #0f3460;
    --border: #1a3a6a;
    --text: #e2e8f0;
    --text-muted: #8899b4;
    --accent: #00d4aa;
    --accent-dim: rgba(0, 212, 170, 0.15);
    --danger: #f56565;
    --danger-dim: rgba(245, 101, 101, 0.15);
    --cat-lifecycle: #f6ad55;
    --cat-core: #63b3ed;
    --cat-form: #b794f4;
    --cat-social: #fc8181;
    --cat-nav: #68d391;
    --cat-notif: #f6e05e;
    --cat-profile: #ed64a6;
    --cat-settings: #4fd1c5;
    --cat-community: #feb2b2;
    --cat-auth: #c4b5fd;
    --cat-system: #a0aec0;
    --radius: 8px;
    --radius-sm: 5px;
    --shadow: 0 2px 8px rgba(0,0,0,0.3);
  }

  body {
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
    font-size: 12px;
    color: var(--text);
    background: var(--bg);
    line-height: 1.5;
    overflow-x: hidden;
  }

  /* â”€â”€â”€ Tabs â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .tabs {
    display: flex;
    border-bottom: 1px solid var(--border);
    background: var(--bg-card);
    position: sticky;
    top: 0;
    z-index: 10;
  }
  .tab {
    flex: 1;
    padding: 10px 4px;
    text-align: center;
    cursor: pointer;
    font-size: 18px;
    color: var(--text-muted);
    border-bottom: 2px solid transparent;
    transition: all 0.2s;
  }
  .tab:hover { color: var(--text); background: rgba(255,255,255,0.03); }
  .tab.active {
    color: var(--accent);
    border-bottom-color: var(--accent);
    background: var(--accent-dim);
  }

  .tab-content { display: none; padding: 12px; }
  .tab-content.active { display: block; }

  /* â”€â”€â”€ Empty / Status States â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .empty-state {
    text-align: center;
    padding: 40px 20px;
    color: var(--text-muted);
  }
  .empty-state .icon { font-size: 32px; margin-bottom: 8px; }
  .empty-state h3 { color: var(--text); font-size: 14px; margin-bottom: 4px; }
  .empty-state p { font-size: 11px; }

  .status-bar {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    margin-bottom: 12px;
  }
  .status-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    background: var(--accent);
    flex-shrink: 0;
  }
  
  /* Issue 10: Sync status colors */
  .status-dot.sync-success { background: #4ade80; } /* Green */
  .status-dot.sync-progress { background: #facc15; } /* Yellow */
  .status-dot.sync-error { background: #f87171; } /* Red */
  .status-dot.empty { background: var(--text-muted); }
  .status-dot.tagged { background: var(--accent); }
  .status-text { font-size: 11px; color: var(--text-muted); flex: 1; }
  .status-text strong { color: var(--text); }

  /* â”€â”€â”€ Form Elements â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  label {
    display: block;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.5px;
    color: var(--text-muted);
    margin-bottom: 4px;
  }

  select, input[type="text"] {
    width: 100%;
    padding: 8px 10px;
    background: var(--bg-input);
    border: 1px solid var(--border);
    border-radius: var(--radius-sm);
    color: var(--text);
    font-size: 12px;
    font-family: inherit;
    outline: none;
    transition: border-color 0.2s;
  }
  select:focus, input[type="text"]:focus {
    border-color: var(--accent);
  }
  select { cursor: pointer; }

  .field { margin-bottom: 12px; }

  /* â”€â”€â”€ Category Badge â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .cat-badge {
    display: inline-block;
    padding: 2px 8px;
    border-radius: 10px;
    font-size: 10px;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 0.3px;
  }

  /* â”€â”€â”€ Properties Editor â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .props-section {
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 10px;
    margin-bottom: 12px;
  }
  .props-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
  }
  .props-header label { margin-bottom: 0; }

  .prop-row {
    display: flex;
    gap: 6px;
    align-items: center;
    margin-bottom: 6px;
  }
  .prop-row input { flex: 1; padding: 6px 8px; font-size: 11px; }
  .prop-row select { width: 80px; flex: none; padding: 6px 4px; font-size: 11px; }
  .prop-remove {
    width: 24px; height: 24px;
    display: flex; align-items: center; justify-content: center;
    background: var(--danger-dim);
    border: 1px solid rgba(245,101,101,0.3);
    border-radius: var(--radius-sm);
    color: var(--danger);
    cursor: pointer;
    font-size: 14px;
    flex-shrink: 0;
    transition: background 0.2s;
  }
  .prop-remove:hover { background: rgba(245,101,101,0.3); }

  .add-prop-btn {
    width: 100%;
    padding: 6px;
    background: var(--accent-dim);
    border: 1px dashed rgba(0,212,170,0.4);
    border-radius: var(--radius-sm);
    color: var(--accent);
    cursor: pointer;
    font-size: 11px;
    font-weight: 600;
    transition: background 0.2s;
  }
  .add-prop-btn:hover { background: rgba(0,212,170,0.25); }

  /* Suggested props chips */
  .suggested-props {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-bottom: 8px;
  }
  .suggested-chip {
    padding: 3px 8px;
    background: rgba(99,179,237,0.15);
    border: 1px solid rgba(99,179,237,0.3);
    border-radius: 10px;
    color: #63b3ed;
    font-size: 10px;
    cursor: pointer;
    transition: all 0.2s;
  }
  .suggested-chip:hover { background: rgba(99,179,237,0.3); }
  .suggested-chip.added {
    background: var(--accent-dim);
    border-color: rgba(0,212,170,0.3);
    color: var(--accent);
  }

  /* â”€â”€â”€ Buttons â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .btn-row { display: flex; gap: 8px; margin-top: 12px; }

  .btn {
    flex: 1;
    padding: 10px 12px;
    border-radius: var(--radius);
    font-size: 12px;
    font-weight: 600;
    cursor: pointer;
    border: none;
    transition: all 0.2s;
    text-align: center;
  }
  .btn-primary {
    background: var(--accent);
    color: #0a0a1a;
  }
  .btn-primary:hover { filter: brightness(1.15); }
  .btn-secondary {
    background: var(--bg-input);
    border: 1px solid var(--border);
    color: var(--text);
  }
  .btn-secondary:hover { border-color: var(--accent); color: var(--accent); }
  .btn-danger {
    background: var(--danger-dim);
    border: 1px solid rgba(245,101,101,0.3);
    color: var(--danger);
  }
  .btn-danger:hover { background: rgba(245,101,101,0.3); }
  .btn-sm { padding: 6px 10px; font-size: 11px; }

  /* â”€â”€â”€ Code Preview â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .code-block {
    position: relative;
    background: #0d1117;
    border: 1px solid var(--border);
    border-radius: var(--radius);
    padding: 12px;
    font-family: 'SF Mono', 'Fira Code', 'Cascadia Code', monospace;
    font-size: 11px;
    line-height: 1.6;
    overflow-x: auto;
    white-space: pre;
    color: #c9d1d9;
    margin-top: 8px;
  }
  .code-block .kw { color: #ff7b72; }
  .code-block .str { color: #a5d6ff; }
  .code-block .fn { color: #d2a8ff; }
  .code-block .cmt { color: #8b949e; }
  .code-block .num { color: #79c0ff; }
  .code-block .prop { color: #ffa657; }

  .copy-btn {
    position: absolute;
    top: 8px;
    right: 8px;
    padding: 4px 10px;
    background: var(--accent);
    color: #0a0a1a;
    border: none;
    border-radius: var(--radius-sm);
    font-size: 10px;
    font-weight: 700;
    cursor: pointer;
    z-index: 2;
    transition: all 0.15s;
  }
  .copy-btn:hover { filter: brightness(1.2); }
  .copy-btn.copied { background: #68d391; }

  /* â”€â”€â”€ Audit List â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .audit-item {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 10px;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    margin-bottom: 6px;
    cursor: pointer;
    transition: all 0.2s;
  }
  .audit-item:hover { border-color: var(--accent); background: var(--accent-dim); }
  .audit-info { flex: 1; min-width: 0; }
  .audit-name { font-weight: 600; font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
  .audit-event { font-size: 11px; color: var(--accent); font-family: monospace; }
  .audit-screen { font-size: 10px; color: var(--text-muted); }
  .audit-count {
    padding: 8px 12px;
    text-align: center;
    background: var(--bg-card);
    border: 1px solid var(--border);
    border-radius: var(--radius);
    margin-bottom: 12px;
  }
  .audit-count .number { font-size: 24px; font-weight: 700; color: var(--accent); }

  /* â”€â”€â”€ Description tooltip â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .event-desc {
    font-size: 10px;
    color: var(--text-muted);
    margin-top: 2px;
    font-style: italic;
  }

  /* â”€â”€â”€ Toast â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .toast {
    position: fixed;
    bottom: 12px;
    left: 12px;
    right: 12px;
    padding: 10px 14px;
    background: var(--accent);
    color: #0a0a1a;
    border-radius: var(--radius);
    font-weight: 600;
    font-size: 12px;
    text-align: center;
    z-index: 100;
    transform: translateY(60px);
    opacity: 0;
    transition: all 0.3s cubic-bezier(0.2, 0, 0, 1);
  }
  .toast.show { transform: translateY(0); opacity: 1; }
  .toast.error { background: var(--danger); color: white; }

  /* â”€â”€â”€ Loading Spinner â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
  .loading-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0, 0, 0, 0.6);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 200;
  }
  .loading-overlay.show { display: flex; }
  
  .spinner {
    width: 40px;
    height: 40px;
    border: 3px solid rgba(0, 212, 170, 0.2);
    border-top-color: var(--accent);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  .loading-text {
    position: absolute;
    margin-top: 80px;
    color: var(--text);
    font-size: 12px;
    font-weight: 500;
  }
</style>
</head>
<body>

<!-- â•â•â• Tabs â•â•â• -->
<div class="tabs">
  <div class="tab active" data-tab="tag" title="Tag">ğŸ·ï¸</div>
  <div class="tab" data-tab="code" title="Code">ğŸ“‹</div>
  <div class="tab" data-tab="audit" title="Audit">ğŸ“Š</div>
  <div class="tab" data-tab="screens" title="Screens">ğŸ–¼ï¸</div>
  <div class="tab" data-tab="settings" title="Settings">âš™ï¸</div>
</div>

<!-- Undo/Redo Bar -->
<div id="undo-redo-bar" style="display:flex;justify-content:flex-end;gap:4px;padding:4px 12px;background:var(--bg);border-bottom:1px solid var(--border);">
  <button id="undo-btn" disabled style="background:none;border:1px solid var(--border);border-radius:var(--radius-sm);padding:2px 10px;cursor:pointer;font-size:12px;color:var(--text-muted);transition:all 0.2s;opacity:0.4;" title="Undo">â†©ï¸ Undo</button>
  <button id="redo-btn" disabled style="background:none;border:1px solid var(--border);border-radius:var(--radius-sm);padding:2px 10px;cursor:pointer;font-size:12px;color:var(--text-muted);transition:all 0.2s;opacity:0.4;" title="Redo">â†ªï¸ Redo</button>
</div>

<!-- â•â•â• TAG TAB â•â•â• -->
<div id="tab-tag" class="tab-content active">
  <div style="font-size:14px;font-weight:700;color:var(--text);margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--border);">
    ğŸ·ï¸ Tag Component
  </div>
  
  <!-- No selection state -->
  <div id="empty-state" class="empty-state">
    <div class="icon">ğŸ¯</div>
    <h3>Select a component</h3>
    <p>Click any layer in Figma to attach analytics metadata.</p>
  </div>

  <!-- Multi-selection state -->
  <div id="multi-state" class="empty-state" style="display:none;">
    <div class="icon">ğŸ“¦</div>
    <h3>Multiple layers selected</h3>
    <p>Select a single component to tag it.</p>
  </div>

  <!-- Tag form -->
  <div id="tag-form" style="display:none;">
    <!-- Screen Frame Info (for components inside screens) -->
    <div id="screen-frame-info" style="display:none;margin-bottom:12px;">
      <div style="padding:10px;background:rgba(104,211,145,0.1);border:1px solid rgba(104,211,145,0.3);border-radius:var(--radius);">
        <div style="font-size:10px;font-weight:600;text-transform:uppercase;letter-spacing:0.5px;color:var(--text-muted);margin-bottom:4px;">ğŸ“ Screen Name (Auto-Derived)</div>
        <div style="color:var(--cat-nav);font-weight:700;font-family:monospace;font-size:14px;margin-bottom:2px;" id="current-screen-frame-name"></div>
        <div style="color:var(--text-muted);font-size:10px;" id="current-screen-frame-layer"></div>
      </div>
    </div>

    <!-- Warning for components not in screen frame -->
    <div id="no-screen-warning" style="display:none;margin-bottom:12px;">
      <div style="padding:10px;background:rgba(245,101,101,0.1);border:1px solid rgba(245,101,101,0.3);border-radius:var(--radius);">
        <div style="font-size:11px;color:var(--danger);font-weight:600;margin-bottom:4px;">âš ï¸ No screen assignment</div>
        <div style="font-size:10px;color:var(--text-muted);">This component is not inside a screen frame. Select a top-level frame and use "Set Screen" to assign it.</div>
      </div>
    </div>

    <div class="status-bar">
      <div class="status-dot" id="status-dot"></div>
      <div class="status-text" id="status-text"></div>
    </div>

    <div class="field">
      <label>Event Category</label>
      <select id="category-select">
        <option value="">â€” All categories â€”</option>
      </select>
    </div>

    <div class="field">
      <label>Event</label>
      <div style="display:flex;gap:4px;">
        <select id="event-select" style="flex:1;">
          <option value="">â€” Select event â€”</option>
        </select>
        <button class="btn btn-secondary btn-sm" id="add-custom-event-btn" style="flex:none;width:32px;padding:4px;" title="Add custom event">+</button>
      </div>
      <div id="event-desc" class="event-desc" style="display:none;"></div>
    </div>

    <div class="field">
      <label>Element Description <span style="color:var(--text-muted);font-weight:400;text-transform:none;">(what is this component?)</span></label>
      <input type="text" id="description-input" placeholder='e.g. "Like button on feed post card"' />
    </div>

    <div class="props-section">
      <div class="props-header">
        <label style="margin:0;">Event Properties</label>
        <span style="font-size:10px;color:var(--text-muted);" id="props-hint">Auto-populated from taxonomy</span>
      </div>
      <div id="suggested-props" class="suggested-props" style="display:none;"></div>
      <div id="props-list"></div>
      <button class="add-prop-btn" id="add-prop-btn">+ Add property</button>
    </div>

    <div class="btn-row">
      <button class="btn btn-primary" id="save-btn">ğŸ’¾ Save Tag</button>
      <button class="btn btn-danger btn-sm" id="clear-btn" style="flex:none;width:80px;">Clear</button>
    </div>
    
    <div class="btn-row" style="margin-top:8px;">
      <button class="btn btn-secondary btn-sm" id="copy-tag-btn">ğŸ“‹ Copy Tag</button>
      <button class="btn btn-secondary btn-sm" id="paste-tag-btn">ğŸ“¥ Paste Tag</button>
    </div>
  </div>
</div>

<!-- â•â•â• CODE TAB â•â•â• -->
<div id="tab-code" class="tab-content">
  <div style="font-size:14px;font-weight:700;color:var(--text);margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--border);">
    ğŸ“‹ Code Snippets
  </div>
  
  <div id="code-empty" class="empty-state">
    <div class="icon">ğŸ“‹</div>
    <h3>No tag on this component</h3>
    <p>Tag a component first, then view the code here.</p>
  </div>

  <div id="code-view" style="display:none;">
    <div class="status-bar">
      <div class="status-text"><strong>React Native snippet</strong> â€” paste onto your component</div>
    </div>

    <div style="margin-bottom:8px;">
      <label>Analytics Props (spread onto component)</label>
      <div class="code-block" id="code-rn-props">
        <button class="copy-btn" id="copy-rn-props">COPY</button>
      </div>
    </div>

    <div style="margin-bottom:8px;">
      <label>Full Segment Payload (for reference)</label>
      <div class="code-block" id="code-segment">
        <button class="copy-btn" id="copy-segment">COPY</button>
      </div>
    </div>

    <div>
      <label>Usage Example</label>
      <div class="code-block" id="code-usage">
        <button class="copy-btn" id="copy-usage">COPY</button>
      </div>
    </div>
  </div>
</div>

<!-- â•â•â• AUDIT TAB â•â•â• -->
<div id="tab-audit" class="tab-content">
  <div style="font-size:14px;font-weight:700;color:var(--text);margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--border);">
    ğŸ“Š Tagged Components
  </div>
  
  <div style="margin-bottom:12px;">
    <button class="btn btn-secondary btn-sm" id="scan-btn" style="width:100%;">ğŸ” Scan Page</button>
  </div>
  <div class="audit-count" id="audit-count" style="display:none;">
    <div class="number" id="audit-number">0</div>
    <div style="font-size:10px;color:var(--text-muted);">tagged components</div>
  </div>
  <div id="audit-list"></div>
  <div id="audit-empty" class="empty-state">
    <div class="icon">ğŸ“Š</div>
    <h3>Click "Scan Page"</h3>
    <p>Find all components on this page that have analytics tags.</p>
  </div>
</div>

<!-- â•â•â• SCREENS TAB â•â•â• -->
<div id="tab-screens" class="tab-content">
  <div style="font-size:14px;font-weight:700;color:var(--text);margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--border);">
    ğŸ–¼ï¸ Screen Frames
  </div>
  
  <!-- Inside Screen Frame Notice (shown when selection is inside an assigned screen) -->
  <div id="screen-frame-inside-notice" style="display:none;margin-bottom:16px;">
    <div class="props-section" style="background:rgba(99,179,237,0.1);border-color:rgba(99,179,237,0.3);">
      <div style="text-align:center;padding:8px 0;">
        <div style="font-size:20px;margin-bottom:6px;">ğŸ“</div>
        <div style="font-size:12px;color:var(--text);font-weight:600;">Inside Screen Frame</div>
        <div style="font-size:11px;color:var(--text-muted);margin-top:4px;">
          This component inherits screen: <strong id="inside-screen-name" style="color:var(--cat-core);font-family:monospace;"></strong>
        </div>
        <div style="font-size:10px;color:var(--text-muted);margin-top:2px;">
          from frame "<span id="inside-frame-name"></span>"
        </div>
      </div>
    </div>
  </div>

  <!-- Screen Frame Assignment (hidden when inside a screen frame) -->
  <div id="screen-frame-assignment-main" style="margin-bottom:16px;">
    <div class="props-section" style="background:rgba(104,211,145,0.1);border-color:rgba(104,211,145,0.3);">
      <div class="props-header">
        <label style="margin:0;">Set Screen on Selected Frame</label>
      </div>
      <div style="font-size:11px;color:var(--text-muted);margin-bottom:8px;">
        Select a top-level frame in Figma to assign it a screen name. Components inside will auto-inherit it.
      </div>
      <div id="screen-frame-current" style="display:none;padding:8px;background:rgba(104,211,145,0.15);border-radius:var(--radius-sm);margin-bottom:8px;">
        <div style="font-size:11px;color:var(--text);">
          <strong>Current:</strong> <span id="screen-frame-current-name" style="color:var(--cat-nav);font-family:monospace;"></span>
        </div>
      </div>
      <div class="field" style="margin-bottom:8px;">
        <label>Screen Name</label>
        <div style="display:flex;gap:4px;">
          <select id="screen-frame-select" style="flex:1;">
            <option value="">â€” Select screen â€”</option>
          </select>
          <button class="btn btn-secondary btn-sm" id="add-custom-screen-btn" style="flex:none;width:32px;padding:4px;" title="Add custom screen">+</button>
        </div>
      </div>
      <div style="display:flex;gap:4px;">
        <button class="btn btn-secondary btn-sm" id="set-screen-frame-btn" style="flex:1;">Set Screen</button>
        <button class="btn btn-danger btn-sm" id="clear-screen-frame-btn" style="flex:none;width:80px;display:none;">Clear</button>
      </div>
    </div>
  </div>
  
  <div style="margin-bottom:12px;">
    <div style="display:flex;gap:8px;">
      <button class="btn btn-secondary btn-sm" id="scan-screens-btn" style="flex:1;">ğŸ” Scan Page for Screens</button>
      <button class="btn btn-sm" id="clear-all-screens-btn" style="flex:none;background:var(--danger-dim);color:var(--danger);border:1px solid var(--danger);cursor:pointer;">ğŸ—‘ï¸ Clear All</button>
    </div>
  </div>
  
  <div id="screens-list"></div>
  <div id="screens-empty" class="empty-state">
    <div class="icon">ğŸ–¼ï¸</div>
    <h3>Click "Scan Page"</h3>
    <p>Find all frames marked as screens on this page.</p>
  </div>
</div>

<!-- â•â•â• SETTINGS TAB â•â•â• -->
<div id="tab-settings" class="tab-content">
  <div style="font-size:14px;font-weight:700;color:var(--text);margin-bottom:12px;padding-bottom:8px;border-bottom:1px solid var(--border);display:flex;justify-content:space-between;align-items:center;">
    <span>âš™ï¸ Settings</span>
    <button id="admin-toggle-btn" style="background:none;border:1px solid var(--border);border-radius:var(--radius-sm);padding:4px 8px;cursor:pointer;font-size:12px;color:var(--text-muted);transition:all 0.2s;" title="Toggle admin mode">ğŸ”’</button>
  </div>
  
  <!-- Non-admin default view -->
  <div id="settings-default-view">
    <div id="settings-configured-view" style="display:none;">
      <div style="text-align:center;padding:24px 20px 16px;">
        <div style="font-size:32px;margin-bottom:8px;">âœ…</div>
        <div style="font-size:14px;font-weight:700;color:var(--text);">Connected to Google Sheets</div>
        <div style="font-size:12px;color:var(--text-muted);margin-top:6px;" id="taxonomy-summary-default">0 screens, 0 events loaded</div>
      </div>
      <div style="padding:0 20px 16px;">
        <button class="btn btn-secondary btn-sm" id="refresh-taxonomy-default-btn" style="width:100%;">ğŸ”„ Refresh Taxonomy</button>
      </div>
      <div style="text-align:center;padding:8px 0 16px;">
        <button id="admin-unlock-btn" style="background:none;border:none;color:var(--text-muted);cursor:pointer;font-size:11px;padding:4px 12px;transition:color 0.2s;">ğŸ”“ Admin</button>
      </div>
    </div>
    
    <div id="settings-unconfigured-view" style="display:none;">
      <div style="text-align:center;padding:24px 20px 16px;">
        <div style="font-size:32px;margin-bottom:8px;">âš ï¸</div>
        <div style="font-size:14px;font-weight:700;color:var(--text);">Not Configured</div>
        <div style="font-size:12px;color:var(--text-muted);margin-top:6px;">Ask your admin to set up this file.</div>
      </div>
      <div style="text-align:center;padding:8px 0 16px;">
        <button id="admin-unlock-btn-unconfigured" style="background:none;border:none;color:var(--text-muted);cursor:pointer;font-size:11px;padding:4px 12px;transition:color 0.2s;">ğŸ”“ Admin</button>
      </div>
    </div>
  </div>
  
  <!-- Admin Password Modal (inline) -->
  <div id="admin-password-modal" style="display:none;padding:16px 20px;">
    <div style="text-align:center;margin-bottom:12px;">
      <div style="font-size:24px;margin-bottom:4px;">ğŸ”</div>
      <div style="font-size:13px;font-weight:600;color:var(--text);">Enter Admin Password</div>
    </div>
    <div class="field">
      <input type="password" id="admin-password-input" placeholder="Password" style="text-align:center;" />
    </div>
    <div class="btn-row" style="margin-top:8px;">
      <button class="btn btn-primary btn-sm" id="admin-password-submit">Unlock</button>
      <button class="btn btn-secondary btn-sm" id="admin-password-cancel">Cancel</button>
    </div>
    <div id="admin-password-error" style="display:none;text-align:center;font-size:11px;color:var(--danger);margin-top:8px;">Incorrect password</div>
  </div>

  <!-- Admin view (hidden by default) -->
  <div id="settings-admin-view" style="display:none;">
  
  <!-- File URL Configuration -->
  <div style="margin-bottom:16px;">
    <div class="status-bar" style="margin-bottom:8px;">
      <div class="status-text"><strong>ğŸ”— Figma File URL</strong></div>
    </div>
    
    <div class="field">
      <label>File URL (for deep links)</label>
      <input type="text" id="figma-url-input" placeholder="https://www.figma.com/design/..." />
      <div style="font-size:10px;color:var(--text-muted);margin-top:4px;">
        Paste any link to this file (use Share button). We'll extract the file key for generating component links.
      </div>
    </div>
    
    <div class="btn-row">
      <button class="btn btn-secondary" id="save-figma-url-btn">ğŸ’¾ Save File URL</button>
    </div>
    
    <div id="figma-url-status" style="font-size:11px;margin-top:8px;padding:8px;border-radius:var(--radius-sm);display:none;"></div>
  </div>
  
  <!-- API Configuration -->
  <div style="margin-bottom:16px;">
    <div class="status-bar" style="margin-bottom:8px;">
      <div class="status-text"><strong>ğŸ“¡ Google Sheets Integration</strong></div>
    </div>
    
    <div class="field">
      <label>Apps Script URL</label>
      <input type="text" id="api-url-input" placeholder="https://script.google.com/macros/s/.../exec" />
      <div style="font-size:10px;color:var(--text-muted);margin-top:4px;">
        Paste your deployed Apps Script web app URL here. <a href="#" id="setup-guide-link" style="color:var(--accent);">Setup guide</a>
      </div>
    </div>
    
    <div class="field">
      <label>API Token</label>
      <input type="text" id="api-token-input" placeholder="Enter your API token" />
      <div style="font-size:10px;color:var(--text-muted);margin-top:4px;">
        This token must match the API_TOKEN constant in your Apps Script deployment for security.
      </div>
    </div>
    
    <div class="btn-row">
      <button class="btn btn-primary" id="save-api-url-btn">ğŸ’¾ Save & Load Taxonomy</button>
      <button class="btn btn-secondary btn-sm" id="refresh-taxonomy-btn" style="flex:none;">ğŸ”„ Refresh</button>
    </div>
    
    <div id="api-status" style="font-size:11px;margin-top:8px;padding:8px;border-radius:var(--radius-sm);display:none;"></div>
  </div>
  
  <!-- Taxonomy Status -->
  <div style="margin-bottom:16px;">
    <div class="status-bar" style="margin-bottom:8px;">
      <div class="status-text"><strong>ğŸ“Š Current Taxonomy</strong></div>
    </div>
    
    <div style="background:var(--bg-card);border:1px solid var(--border);border-radius:var(--radius);padding:10px;">
      <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
        <span style="font-size:11px;color:var(--text-muted);">Screens:</span>
        <span style="font-size:11px;font-weight:600;" id="taxonomy-screens-count">0</span>
      </div>
      <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
        <span style="font-size:11px;color:var(--text-muted);">Events:</span>
        <span style="font-size:11px;font-weight:600;" id="taxonomy-events-count">0</span>
      </div>
      <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
        <span style="font-size:11px;color:var(--text-muted);">Custom Screens:</span>
        <span style="font-size:11px;font-weight:600;color:var(--accent);" id="taxonomy-custom-screens-count">0</span>
      </div>
      <div style="display:flex;justify-content:space-between;">
        <span style="font-size:11px;color:var(--text-muted);">Custom Events:</span>
        <span style="font-size:11px;font-weight:600;color:var(--accent);" id="taxonomy-custom-events-count">0</span>
      </div>
      <div style="font-size:10px;color:var(--text-muted);margin-top:8px;font-style:italic;" id="taxonomy-source">
        Using hardcoded data (fallback)
      </div>
    </div>
  </div>
  
  <!-- Manage Custom Entries -->
  <div>
    <div class="status-bar" style="margin-bottom:8px;">
      <div class="status-text"><strong>ğŸ¨ Manage Custom Entries</strong></div>
    </div>
    
    <div id="custom-entries-list">
      <div class="empty-state" style="padding:20px;">
        <div class="icon" style="font-size:24px;">ğŸ“</div>
        <p style="font-size:11px;">No custom entries yet. Add custom screens or events from the Tag tab.</p>
      </div>
    </div>
  </div>
  
  </div><!-- /settings-admin-view -->
</div>

<!-- â•â•â• Custom Entry Modal â•â•â• -->
<div id="custom-entry-modal" style="display:none;position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.7);z-index:200;padding:20px;">
  <div style="background:var(--bg);border-radius:var(--radius);max-width:360px;margin:40px auto;padding:16px;box-shadow:var(--shadow);">
    <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
      <h3 style="font-size:14px;font-weight:600;" id="modal-title">Add Custom Entry</h3>
      <button id="modal-close-btn" style="background:none;border:none;color:var(--text);font-size:20px;cursor:pointer;padding:0;width:24px;height:24px;">Ã—</button>
    </div>
    
    <div id="modal-content"></div>
    
    <div class="btn-row" style="margin-top:12px;">
      <button class="btn btn-primary" id="modal-save-btn">Save</button>
      <button class="btn btn-secondary" id="modal-cancel-btn">Cancel</button>
    </div>
  </div>
</div>

<!-- â•â•â• Toast â•â•â• -->
<div class="toast" id="toast"></div>

<!-- â•â•â• Loading Spinner â•â•â• -->
<div class="loading-overlay" id="loading-overlay">
  <div class="spinner"></div>
  <div class="loading-text" id="loading-text">Loading...</div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// TAXONOMY DATA (extracted from the Tallo spreadsheet)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// FALLBACK DATA: This hardcoded data is only used when the Google Sheet API fails
// The Google Sheet is the source of truth - this should match the 73 screens from the sheet
// Removed: learn__courses_list, search__main (not in the Google Sheet)
// Taxonomy is loaded from Google Sheets (source of truth)
// No hardcoded fallback â€” empty until API loads
const SCREENS = [];

const EVENTS = [];

const PROPERTY_TYPES = {};

const CAT_COLORS = {
  "Lifecycle":          "var(--cat-lifecycle)",
  "Core Actions":       "var(--cat-core)",
  "Form & Input":       "var(--cat-form)",
  "Social & Engagement":"var(--cat-social)",
  "Navigation":         "var(--cat-nav)",
  "Notifications":      "var(--cat-notif)",
  "Profile":            "var(--cat-profile)",
  "Settings":           "var(--cat-settings)",
  "Community":          "var(--cat-community)",
  "Auth / Onboarding":  "var(--cat-auth)",
  "System / Modal":     "var(--cat-system)",
};

// Derived dynamically â€” rebuilt when events load from API
let CATEGORIES = [];

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// STATE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let currentNode = null;
let currentData = null;
let currentScreenFrame = null;
let customProps = []; // { key, type, value_hint }

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// INIT â€” Populate dropdowns
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function init() {
  // Populate screen frame dropdown (for setting screens on frames)
  const screenFrameSel = document.getElementById("screen-frame-select");
  if (screenFrameSel) {
    screenFrameSel.innerHTML = '<option value="">â€” Select screen â€”</option>';
    
    // Group screens by category
    const grouped = {};
    
    SCREENS.forEach(screen => {
      // Handle both object format (new) and string format (old/fallback)
      let screenName, category;
      
      if (typeof screen === 'object' && screen.name) {
        screenName = screen.name;
        category = screen.category || "Other";
      } else if (typeof screen === 'string') {
        // Fallback for old string format
        screenName = screen;
        category = "Other";
      } else {
        return; // Skip invalid entries
      }
      
      if (!grouped[category]) grouped[category] = [];
      grouped[category].push(screenName);
    });
    
    // Sort categories: Custom first, then alphabetically
    const sortedCategories = Object.keys(grouped).sort((a, b) => {
      if (a === "Custom") return -1;
      if (b === "Custom") return 1;
      return a.localeCompare(b);
    });
    
    // Add optgroups for each category
    sortedCategories.forEach(category => {
      const og = document.createElement("optgroup");
      og.label = category === "Custom" ? "âœ¨ Custom Screens" : category;
      grouped[category].sort().forEach(screenName => {
        const opt = document.createElement("option");
        opt.value = screenName;
        opt.textContent = screenName;
        og.appendChild(opt);
      });
      screenFrameSel.appendChild(og);
    });
  }

  const catSel = document.getElementById("category-select");
  // Clear existing options (keep the first placeholder)
  catSel.innerHTML = '<option value="">â€” All categories â€”</option>';
  CATEGORIES.forEach(c => {
    const opt = document.createElement("option");
    opt.value = c;
    opt.textContent = c;
    catSel.appendChild(opt);
  });

  populateEvents();
}

function populateEvents(filterCat) {
  const eventSel = document.getElementById("event-select");
  const currentVal = eventSel.value;
  eventSel.innerHTML = '<option value="">â€” Select event â€”</option>';

  const filtered = filterCat ? EVENTS.filter(e => e.cat === filterCat) : EVENTS;

  // Group by category
  const grouped = {};
  filtered.forEach(e => {
    if (!grouped[e.cat]) grouped[e.cat] = [];
    grouped[e.cat].push(e);
  });

  Object.keys(grouped).forEach(cat => {
    const og = document.createElement("optgroup");
    og.label = cat;
    grouped[cat].forEach(e => {
      const opt = document.createElement("option");
      opt.value = e.event;
      opt.textContent = e.event;
      og.appendChild(opt);
    });
    eventSel.appendChild(og);
  });

  // Restore selection if still valid
  if (currentVal && filtered.some(e => e.event === currentVal)) {
    eventSel.value = currentVal;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// PROPERTIES EDITOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderProps() {
  const list = document.getElementById("props-list");
  list.innerHTML = "";
  customProps.forEach((p, i) => {
    const row = document.createElement("div");
    row.className = "prop-row";
    row.innerHTML = `
      <input type="text" placeholder="key" value="${escHtml(p.key)}" data-idx="${i}" data-field="key" />
      <select data-idx="${i}" data-field="type">
        <option value="string" ${p.type==='string'?'selected':''}>string</option>
        <option value="integer" ${p.type==='integer'?'selected':''}>int</option>
        <option value="boolean" ${p.type==='boolean'?'selected':''}>bool</option>
        <option value="enum" ${p.type==='enum'?'selected':''}>enum</option>
      </select>
      <div class="prop-remove" data-idx="${i}">Ã—</div>
    `;
    list.appendChild(row);
  });

  // Wire up events
  list.querySelectorAll("input, select").forEach(el => {
    el.addEventListener("change", (e) => {
      const idx = parseInt(e.target.dataset.idx);
      const field = e.target.dataset.field;
      customProps[idx][field] = e.target.value;
    });
  });
  list.querySelectorAll(".prop-remove").forEach(el => {
    el.addEventListener("click", (e) => {
      const idx = parseInt(e.currentTarget.dataset.idx);
      customProps.splice(idx, 1);
      renderProps();
    });
  });
}

function showSuggestedProps(eventName) {
  const ev = EVENTS.find(e => e.event === eventName);
  const container = document.getElementById("suggested-props");
  if (!ev || ev.props.length === 0) {
    container.style.display = "none";
    return;
  }
  const validProps = ev.props.filter(p => p && p.trim() && !/^[-_]+$/.test(p.trim()));
  if (validProps.length === 0) {
    container.style.display = "none";
    return;
  }
  container.style.display = "flex";
  container.innerHTML = "";
  validProps.forEach(propName => {
    const chip = document.createElement("div");
    chip.className = "suggested-chip";
    if (customProps.some(p => p.key === propName)) chip.classList.add("added");
    chip.textContent = propName;
    chip.addEventListener("click", () => {
      if (!customProps.some(p => p.key === propName)) {
        customProps.push({
          key: propName,
          type: PROPERTY_TYPES[propName] || "string",
        });
        renderProps();
        chip.classList.add("added");
      }
    });
    container.appendChild(chip);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CODE GENERATION
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function generateRNProps(data) {
  const lines = [];
  lines.push(`analyticsEvent="${data.event}"`);
  lines.push(`analyticsScreen="${data.screen_name}"`);
  if (data.properties && Object.keys(data.properties).length > 0) {
    lines.push(`analyticsProps={${JSON.stringify(data.properties)}}`);
  }
  return lines.join("\n");
}

function generateSegmentPayload(data) {
  const payload = {
    type: "track",
    event: data.event,
    properties: {
      screen_name: data.screen_name,
      platform: "mobile_ios | mobile_android",
      app_version: "{{app_version}}",
      session_id: "{{session_id}}",
      ...(data.properties || {}),
    },
  };
  return JSON.stringify(payload, null, 2);
}

function generateUsageExample(data) {
  const propsStr = data.properties && Object.keys(data.properties).length > 0
    ? `\n          analyticsProps={${JSON.stringify(data.properties)}}`
    : "";
  return `<Touchable
          analyticsEvent="${data.event}"
          analyticsScreen="${data.screen_name}"${propsStr}
          onPress={handlePress}
        >
          {/* ${data.description || data.event} */}
        </Touchable>`;
}

function updateCodeTab() {
  if (!currentData) {
    document.getElementById("code-empty").style.display = "";
    document.getElementById("code-view").style.display = "none";
    return;
  }
  document.getElementById("code-empty").style.display = "none";
  document.getElementById("code-view").style.display = "";

  document.getElementById("code-rn-props").innerHTML =
    `<button class="copy-btn" id="copy-rn-props">COPY</button>` + escHtml(generateRNProps(currentData));
  document.getElementById("code-segment").innerHTML =
    `<button class="copy-btn" id="copy-segment">COPY</button>` + escHtml(generateSegmentPayload(currentData));
  document.getElementById("code-usage").innerHTML =
    `<button class="copy-btn" id="copy-usage">COPY</button>` + escHtml(generateUsageExample(currentData));

  // Re-bind copy buttons
  bindCopyBtn("copy-rn-props", () => generateRNProps(currentData));
  bindCopyBtn("copy-segment", () => generateSegmentPayload(currentData));
  bindCopyBtn("copy-usage", () => generateUsageExample(currentData));
}

function bindCopyBtn(id, textFn) {
  const btn = document.getElementById(id);
  if (!btn) return;
  btn.addEventListener("click", async () => {
    const text = textFn();
    try {
      await copyToClipboard(text);
      btn.textContent = "COPIED âœ“";
      btn.classList.add("copied");
      setTimeout(() => { btn.textContent = "COPY"; btn.classList.remove("copied"); }, 1500);
      showToast("Copied to clipboard!");
    } catch (err) {
      console.error("Copy failed:", err);
      showToast("Failed to copy to clipboard", true);
    }
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SELECTION HANDLING (messages from Figma)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

window.onmessage = async (event) => {
  const msg = event.data.pluginMessage;
  if (!msg) return;

  if (msg.type === "selection") {
    if (!msg.node) {
      currentNode = null;
      currentData = null;
      currentScreenFrame = null;
      document.getElementById("empty-state").style.display = "";
      document.getElementById("multi-state").style.display = "none";
      document.getElementById("tag-form").style.display = "none";
      // Reset screens tab
      document.getElementById("screen-frame-inside-notice").style.display = "none";
      document.getElementById("screen-frame-assignment-main").style.display = "block";
    } else {
      currentNode = msg.node;
      currentData = msg.data;
      currentScreenFrame = msg.screenFrame;
      document.getElementById("empty-state").style.display = "none";
      document.getElementById("multi-state").style.display = "none";
      document.getElementById("tag-form").style.display = "";
      loadFormFromData(msg.node, msg.data, msg.screenFrame);
      
      // Update Screens tab if a frame is selected
      updateScreensTabForSelection(msg.node);
    }
    updateCodeTab();
  }

  if (msg.type === "selection-multi") {
    currentNode = null;
    currentData = null;
    document.getElementById("empty-state").style.display = "none";
    document.getElementById("multi-state").style.display = "";
    document.getElementById("tag-form").style.display = "none";
    updateCodeTab();
  }

  if (msg.type === "error") {
    showToast(msg.message, true);
  }

  if (msg.type === "scan-results") {
    hideLoading();
    renderAuditResults(msg.results);
  }

  if (msg.type === "export-results") {
    hideLoading();
    await downloadJSON(msg.results);
  }

  if (msg.type === "screen-frames-results") {
    hideLoading();
    renderScreenFrames(msg.results);
  }

  if (msg.type === "screen-frames-cleared") {
    // Re-scan after clearing
    showToast(`Cleared ${msg.count} screen assignment${msg.count !== 1 ? 's' : ''}`);
    parent.postMessage({ pluginMessage: { type: "scan-screen-frames" } }, "*");
  }

  if (msg.type === "tag-pasted") {
    // Load the pasted data into the form
    const pastedData = msg.data;
    if (pastedData) {
      document.getElementById("event-select").value = pastedData.event || "";
      document.getElementById("description-input").value = pastedData.description || "";
      
      // Load category from pasted data, or fall back to event definition
      const catSel = document.getElementById("category-select");
      if (pastedData.category) {
        catSel.value = pastedData.category;
      } else {
        // Fallback: derive from EVENTS array if not in pasted data
        const ev = EVENTS.find(e => e.event === pastedData.event);
        if (ev) {
          catSel.value = ev.cat;
        }
      }
      
      // Load properties
      customProps = [];
      if (pastedData.properties) {
        Object.entries(pastedData.properties).forEach(([key, type]) => {
          customProps.push({ key, type: typeof type === "string" ? type : "string" });
        });
      }
      renderProps();
      
      // Show event description
      const ev = EVENTS.find(e => e.event === pastedData.event);
      if (ev) {
        showEventDescription(ev);
        showSuggestedProps(pastedData.event);
      }
      
      showToast("Tag pasted! Remember to save.");
    }
  }

  if (msg.type === "sync-data") {
    // Silent mode if this was triggered by auto-sync
    const isAutoSync = msg.isAutoSync || false;
    await syncTagsToSheet(msg.tags, msg.fileName, msg.fileKey, msg.screenFrames, isAutoSync);
  }

  if (msg.type === "log-change") {
    // Issue 5: Batch changes instead of making separate API calls
    // Add to pending changes array that will be included in the next sync
    pendingChanges.push({
      fileName: "Figma File",
      nodeId: msg.nodeId,
      nodeName: msg.nodeName,
      action: msg.action,
      field: "tag",
      oldValue: msg.oldValue,
      newValue: msg.newValue
    });
  }

  if (msg.type === "api-url-loaded") {
    apiUrl = msg.url;
    apiToken = msg.token;
    if (apiUrl) {
      document.getElementById("api-url-input").value = apiUrl;
    }
    if (apiToken) {
      document.getElementById("api-token-input").value = apiToken;
    }
    if (apiUrl && apiToken) {
      await loadTaxonomyFromAPI();
    }
    updateTaxonomyStatus();
    updateSettingsView();
  }

  if (msg.type === "figma-filekey-loaded") {
    figmaFileKey = msg.fileKey;
    if (figmaFileKey) {
      const statusEl = document.getElementById("figma-url-status");
      statusEl.style.display = "block";
      statusEl.style.background = "var(--cat-nav-dim)";
      statusEl.style.color = "var(--cat-nav)";
      statusEl.textContent = `âœ… File key loaded: ${figmaFileKey}`;
    }
  }

  if (msg.type === "screen-assignment") {
    const select = document.getElementById("screen-frame-select");
    const currentDiv = document.getElementById("screen-frame-current");
    const currentName = document.getElementById("screen-frame-current-name");
    const clearBtn = document.getElementById("clear-screen-frame-btn");
    
    if (msg.screenName) {
      select.value = msg.screenName;
      currentDiv.style.display = "block";
      currentName.textContent = msg.screenName;
      clearBtn.style.display = "block";
    } else {
      select.value = "";
      currentDiv.style.display = "none";
      clearBtn.style.display = "none";
    }
  }

  if (msg.type === "trigger-auto-sync") {
    // Debounce auto-sync to avoid too many rapid syncs
    // Wait 2 seconds after the last change before syncing
    if (autoSyncTimeout) {
      clearTimeout(autoSyncTimeout);
    }
    
    autoSyncTimeout = setTimeout(async () => {
      if (!apiUrl) {
        console.log("Auto-sync skipped: No API URL configured");
        return;
      }
      
      console.log("Auto-syncing to Google Sheets...");
      // Request all tags and screen frames from Figma (marked as auto-sync)
      parent.postMessage({ pluginMessage: { type: "sync-to-sheet", isAutoSync: true } }, "*");
    }, 2000);
  }
};

function updateScreensTabForSelection(node) {
  const isFrame = node.type === "FRAME" || node.type === "COMPONENT" || node.type === "COMPONENT_SET";
  const assignmentDiv = document.getElementById("screen-frame-assignment-main");
  const insideNotice = document.getElementById("screen-frame-inside-notice");
  
  // Check if this node is INSIDE an existing screen frame (but not the screen frame itself)
  const isInsideScreenFrame = currentScreenFrame && currentScreenFrame.id !== node.id;
  
  if (isInsideScreenFrame) {
    // Node is inside a screen frame â€” show notice, hide assignment controls
    insideNotice.style.display = "block";
    assignmentDiv.style.display = "none";
    document.getElementById("inside-screen-name").textContent = currentScreenFrame.screenName;
    document.getElementById("inside-frame-name").textContent = currentScreenFrame.name;
  } else if (isFrame) {
    // Top-level frame â€” show assignment controls, hide notice
    insideNotice.style.display = "none";
    assignmentDiv.style.display = "block";
    parent.postMessage({ pluginMessage: { type: "get-screen-assignment", nodeId: node.id } }, "*");
  } else {
    // Not a frame and not inside a screen â€” show assignment with hint
    insideNotice.style.display = "none";
    assignmentDiv.style.display = "block";
  }
};

function loadFormFromData(node, data, screenFrame) {
  const dot = document.getElementById("status-dot");
  const text = document.getElementById("status-text");
  
  // Handle screen frame info display
  const screenFrameInfo = document.getElementById("screen-frame-info");
  const noScreenWarning = document.getElementById("no-screen-warning");
  
  if (screenFrame) {
    screenFrameInfo.style.display = "block";
    noScreenWarning.style.display = "none";
    document.getElementById("current-screen-frame-name").textContent = screenFrame.screenName;
    document.getElementById("current-screen-frame-layer").textContent = "from frame \"" + screenFrame.name + "\"";
  } else {
    screenFrameInfo.style.display = "none";
    noScreenWarning.style.display = "block";
  }

  if (data) {
    dot.className = "status-dot tagged";
    text.innerHTML = `<strong>${escHtml(node.name)}</strong> â€” tagged âœ“`;
    document.getElementById("event-select").value = data.event || "";
    document.getElementById("description-input").value = data.description || "";

    // Load category from saved data, or fall back to event definition
    const catSel = document.getElementById("category-select");
    if (data.category) {
      catSel.value = data.category;
    } else {
      // Fallback: derive from EVENTS array if not saved (backwards compatibility)
      const ev = EVENTS.find(e => e.event === data.event);
      if (ev) {
        catSel.value = ev.cat;
      }
    }

    // Load properties
    customProps = [];
    if (data.properties) {
      Object.entries(data.properties).forEach(([key, type]) => {
        customProps.push({ key, type: typeof type === "string" ? type : "string" });
      });
    }
    renderProps();

    // Show event description
    const ev = EVENTS.find(e => e.event === data.event);
    if (ev) {
      showEventDescription(ev);
      showSuggestedProps(data.event);
    }
  } else {
    dot.className = "status-dot empty";
    text.innerHTML = `<strong>${escHtml(node.name)}</strong> â€” no tag`;
    document.getElementById("category-select").value = "";
    document.getElementById("event-select").value = "";
    document.getElementById("description-input").value = "";
    document.getElementById("event-desc").style.display = "none";
    document.getElementById("suggested-props").style.display = "none";
    customProps = [];
    renderProps();
  }
}

function showEventDescription(ev) {
  const descEl = document.getElementById("event-desc");
  if (ev) {
    const color = CAT_COLORS[ev.cat] || "var(--text-muted)";
    descEl.innerHTML = `<span class="cat-badge" style="background:${color}20;color:${color};">${ev.cat}</span> ${escHtml(ev.desc)}`;
    descEl.style.display = "";
  } else {
    descEl.style.display = "none";
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// AUDIT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderAuditResults(results) {
  const list = document.getElementById("audit-list");
  const empty = document.getElementById("audit-empty");
  const countEl = document.getElementById("audit-count");

  if (results.length === 0) {
    list.innerHTML = "";
    empty.style.display = "";
    countEl.style.display = "none";
    return;
  }

  empty.style.display = "none";
  countEl.style.display = "";
  document.getElementById("audit-number").textContent = results.length;

  list.innerHTML = "";
  results.forEach(r => {
    const ev = EVENTS.find(e => e.event === r.data.event);
    const color = ev ? (CAT_COLORS[ev.cat] || "var(--text-muted)") : "var(--text-muted)";
    const item = document.createElement("div");
    item.className = "audit-item";
    item.innerHTML = `
      <div style="width:4px;height:32px;border-radius:2px;background:${color};flex-shrink:0;"></div>
      <div class="audit-info">
        <div class="audit-name">${escHtml(r.name)}</div>
        <div class="audit-event">${escHtml(r.data.event || "â€”")}</div>
        <div class="audit-screen">${escHtml(r.data.screen_name || "â€”")}</div>
      </div>
    `;
    item.addEventListener("click", () => {
      parent.postMessage({ pluginMessage: { type: "select-node", nodeId: r.id } }, "*");
    });
    list.appendChild(item);
  });
}

async function downloadJSON(results) {
  if (results.length === 0) {
    showToast("No tagged components found.", true);
    return;
  }
  const json = JSON.stringify(results, null, 2);
  try {
    await copyToClipboard(json);
    showToast(`Copied ${results.length} tags as JSON!`);
  } catch (err) {
    console.error("Copy failed:", err);
    showToast("Failed to copy JSON to clipboard", true);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// EVENT LISTENERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Tabs
document.querySelectorAll(".tab").forEach(tab => {
  tab.addEventListener("click", () => {
    document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));
    document.querySelectorAll(".tab-content").forEach(c => c.classList.remove("active"));
    tab.classList.add("active");
    document.getElementById("tab-" + tab.dataset.tab).classList.add("active");
  });
});

// Category filter
document.getElementById("category-select").addEventListener("change", (e) => {
  populateEvents(e.target.value || null);
});

// Event selection â†’ show description + suggested props
document.getElementById("event-select").addEventListener("change", (e) => {
  const ev = EVENTS.find(ev => ev.event === e.target.value);
  showEventDescription(ev);
  showSuggestedProps(e.target.value);

  // Auto-set category to match event's category
  if (ev && ev.cat) {
    const catSel = document.getElementById("category-select");
    catSel.value = ev.cat;
  }

  // Auto-add required props if empty
  if (ev && ev.props.length > 0 && customProps.length === 0) {
    ev.props.forEach(propName => {
      customProps.push({
        key: propName,
        type: PROPERTY_TYPES[propName] || "string",
      });
    });
    renderProps();
  }
});

// Add property
document.getElementById("add-prop-btn").addEventListener("click", () => {
  customProps.push({ key: "", type: "string" });
  renderProps();
  // Focus last input
  const inputs = document.querySelectorAll("#props-list input[data-field='key']");
  if (inputs.length) inputs[inputs.length - 1].focus();
});

// Save
document.getElementById("save-btn").addEventListener("click", () => {
  const event = document.getElementById("event-select").value;
  const category = document.getElementById("category-select").value;
  const desc = document.getElementById("description-input").value.trim();

  if (!event) {
    showToast("Please select an event.", true);
    return;
  }

  // Screen name must come from screen frame
  if (!currentScreenFrame) {
    showToast("Component must be inside a screen frame. Select a frame and use 'Set Screen' first.", true);
    return;
  }

  const screen = currentScreenFrame.screenName;

  const properties = {};
  customProps.forEach(p => {
    if (p.key.trim()) {
      properties[p.key.trim()] = p.type;
    }
  });

  const oldData = currentData ? JSON.stringify(currentData) : null;
  
  const data = {
    event,
    category,
    screen_name: screen,
    description: desc,
    properties,
    tagged_at: new Date().toISOString(),
  };

  currentData = data;
  
  // Show brief loading state
  const saveBtn = document.getElementById("save-btn");
  const originalText = saveBtn.innerHTML;
  saveBtn.innerHTML = "ğŸ’¾ Saving...";
  saveBtn.disabled = true;
  
  parent.postMessage({ pluginMessage: { type: "save", data, oldData } }, "*");
  
  // Push to undo stack
  pushUndo({
    type: "save-tag",
    nodeId: currentNode.id,
    oldData: oldData ? JSON.parse(oldData) : null,
    newData: data,
    description: `Tag "${event}" on "${currentNode.name}"`
  });
  
  updateCodeTab();
  
  // Reset button after a moment
  setTimeout(() => {
    saveBtn.innerHTML = originalText;
    saveBtn.disabled = false;
  }, 1000);
});

// Clear
document.getElementById("clear-btn").addEventListener("click", () => {
  // Push to undo before clearing
  if (currentNode && currentData) {
    pushUndo({
      type: "clear-tag",
      nodeId: currentNode.id,
      oldData: { ...currentData },
      newData: null,
      description: `Clear tag from "${currentNode.name}"`
    });
  }
  parent.postMessage({ pluginMessage: { type: "clear" } }, "*");
  currentData = null;
  updateCodeTab();
});

// Scan tags
document.getElementById("scan-btn").addEventListener("click", () => {
  showLoading("Scanning page for tagged components...");
  parent.postMessage({ pluginMessage: { type: "scan-page" } }, "*");
  
  // Hide loading after results come back (will be handled by message handler)
  setTimeout(() => hideLoading(), 3000);
});

// Scan screen frames
document.getElementById("scan-screens-btn").addEventListener("click", () => {
  showLoading("Scanning page for screen frames...");
  parent.postMessage({ pluginMessage: { type: "scan-screen-frames" } }, "*");
  
  // Hide loading after results come back (will be handled by message handler)
  setTimeout(() => hideLoading(), 3000);
});

// Clear all screen frame assignments
document.getElementById("clear-all-screens-btn").addEventListener("click", () => {
  parent.postMessage({ pluginMessage: { type: "clear-all-screen-frames" } }, "*");
});

// Queued for deletion - Export JSON and Sync to Sheet buttons removed (auto-sync now handles syncing)
// 
// document.getElementById("export-btn").addEventListener("click", () => {
//   parent.postMessage({ pluginMessage: { type: "export-all" } }, "*");
// });
// 
// document.getElementById("sync-sheet-btn").addEventListener("click", async () => {
//   if (!apiUrl) {
//     showToast("Please configure API URL in Settings first", true);
//     return;
//   }
//   
//   // Request all tags from Figma
//   parent.postMessage({ pluginMessage: { type: "sync-to-sheet" } }, "*");
// });

// Set screen frame
document.getElementById("set-screen-frame-btn").addEventListener("click", () => {
  const screenName = document.getElementById("screen-frame-select").value.trim();
  if (!screenName) {
    showToast("Please select a screen name", true);
    return;
  }
  
  // Show brief loading state
  const btn = document.getElementById("set-screen-frame-btn");
  const originalText = btn.innerHTML;
  btn.innerHTML = "â³ Setting...";
  btn.disabled = true;
  
  // Push to undo (oldData = current screen name if any)
  if (currentNode) {
    const oldScreen = document.getElementById("screen-frame-current-name").textContent || null;
    pushUndo({
      type: "set-screen",
      nodeId: currentNode.id,
      oldData: oldScreen || null,
      newData: screenName,
      description: `Set screen "${screenName}" on "${currentNode.name}"`
    });
  }
  
  parent.postMessage({ pluginMessage: { type: "set-screen-frame", screenName } }, "*");
  
  // Reset button after a moment
  setTimeout(() => {
    btn.innerHTML = originalText;
    btn.disabled = false;
  }, 1000);
});

// Clear screen frame
document.getElementById("clear-screen-frame-btn").addEventListener("click", () => {
  // Push to undo
  if (currentNode) {
    const oldScreen = document.getElementById("screen-frame-current-name").textContent || null;
    if (oldScreen) {
      pushUndo({
        type: "clear-screen",
        nodeId: currentNode.id,
        oldData: oldScreen,
        newData: null,
        description: `Clear screen from "${currentNode.name}"`
      });
    }
  }
  parent.postMessage({ pluginMessage: { type: "clear-screen-frame" } }, "*");
});

// Render screen frames list
// Cleanup orphaned screen frame assignments after taxonomy refresh
function cleanupOrphanedScreenFrames() {
  // Trigger a scan â€” renderScreenFrames will handle orphan removal
  parent.postMessage({ pluginMessage: { type: "scan-screen-frames" } }, "*");
}

// Track if we're currently in a cleanup cycle to avoid infinite loops
let isCleaningOrphans = false;

function renderScreenFrames(results) {
  // Always check for orphans when SCREENS has been loaded from API
  // (taxonomyData is set when API has been called at least once)
  if (taxonomyData && !isCleaningOrphans && results.length > 0) {
    // If taxonomy loaded but SCREENS is empty, ALL assignments are orphans
    // If SCREENS has data, only assignments not in SCREENS are orphans
    const validNames = new Set(SCREENS.map(s => s.name));
    const orphanIds = results
      .filter(r => SCREENS.length === 0 || !validNames.has(r.screenName))
      .map(r => r.id);
    
    if (orphanIds.length > 0) {
      isCleaningOrphans = true;
      parent.postMessage({ pluginMessage: { type: "clear-screen-frames", nodeIds: orphanIds } }, "*");
      showToast(`Removing ${orphanIds.length} orphaned screen assignment${orphanIds.length > 1 ? 's' : ''}...`);
      return; // Will re-render after clear completes
    }
  }
  isCleaningOrphans = false;

  const list = document.getElementById("screens-list");
  const empty = document.getElementById("screens-empty");
  
  if (results.length === 0) {
    list.style.display = "none";
    empty.style.display = "block";
    return;
  }
  
  list.style.display = "block";
  empty.style.display = "none";
  list.innerHTML = "";
  
  results.forEach(screen => {
    const item = document.createElement("div");
    item.className = "audit-item";
    item.innerHTML = `
      <div style="width:4px;height:32px;border-radius:2px;background:var(--cat-nav);flex-shrink:0;"></div>
      <div class="audit-info">
        <div class="audit-name">${escHtml(screen.name)}</div>
        <div class="audit-event">${escHtml(screen.screenName)}</div>
        <div class="audit-screen">${escHtml(screen.type)}</div>
      </div>
    `;
    item.addEventListener("click", () => {
      parent.postMessage({ pluginMessage: { type: "select-node", nodeId: screen.id } }, "*");
    });
    list.appendChild(item);
  });
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// COPY/PASTE TAG
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Copy tag button
document.getElementById("copy-tag-btn").addEventListener("click", () => {
  if (!currentData) {
    showToast("No tag to copy", true);
    return;
  }
  
  // Copy everything except screen_name and tagged_at
  const tagToCopy = {
    event: currentData.event,
    category: currentData.category,
    description: currentData.description,
    properties: currentData.properties
  };
  
  parent.postMessage({ pluginMessage: { type: "copy-tag", data: tagToCopy } }, "*");
  showToast("Tag copied to clipboard!");
});

// Paste tag button
document.getElementById("paste-tag-btn").addEventListener("click", () => {
  parent.postMessage({ pluginMessage: { type: "paste-tag" } }, "*");
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// VERSION CONTROL â€” Change History & Sync
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Issue 5: This function kept for backward compatibility but no longer used
// Changes are now batched into the syncTags call for better efficiency
async function logChange(changeAction, nodeId, nodeName, field, oldValue, newValue) {
  if (!apiUrl) return; // Silently skip if API not configured
  
  try {
    await fetch(apiUrl, {
      method: "POST",
      body: JSON.stringify({
        action: "logChange",
        token: apiToken,
        fileName: "Figma File",
        nodeId: nodeId,
        nodeName: nodeName,
        changeAction: changeAction,
        field: field,
        oldValue: oldValue || "",
        newValue: newValue || ""
      })
    });
    // Silently succeed - don't interrupt user flow
  } catch (err) {
    // Silently fail - logging is not critical
    console.error("Failed to log change:", err);
  }
}

async function syncTagsToSheet(tags, fileName, fileKey, screenFrames, silent = false) {
  if (!apiUrl) {
    if (!silent) {
      showToast("Please configure API URL in Settings first", true);
      updateSyncStatus("error", "API URL not configured");
    }
    return;
  }
  
  // Issue 10: Update sync status indicator
  updateSyncStatus("progress", "Syncing...");
  
  if (!silent) {
    showLoading("Syncing to Google Sheets...");
  }
  
  try {
    // Issue 5: Include pending changes in sync call
    const changesToSend = [...pendingChanges]; // Copy the array
    pendingChanges.length = 0; // Clear pending changes
    
    const response = await fetch(apiUrl, {
      method: "POST",
      body: JSON.stringify({
        action: "syncTags",
        token: apiToken,
        fileName: fileName || "Figma File",
        fileKey: fileKey || "",
        tags: tags,
        screenFrames: screenFrames || [],
        changes: changesToSend // Include batched changes
      })
    });
    
    const result = await response.json();
    if (!result.success) throw new Error(result.error || "Failed to sync");
    
    // Issue 10: Update status on success
    updateSyncStatus("success", "Synced");
    
    if (!silent) {
      hideLoading();
      showToast(`âœ… Synced ${result.count} tags and ${result.screenCount || 0} screens to Google Sheets!`);
    } else {
      console.log(`Auto-synced ${result.count} tags and ${result.screenCount || 0} screens to Google Sheets`);
    }
    
  } catch (err) {
    if (!silent) {
      hideLoading();
      showToast("Failed to sync: " + err.message, true);
      updateSyncStatus("error", "Sync failed");
    } else {
      console.error("Auto-sync failed:", err);
      // Issue 10: Retry mechanism for auto-sync failures
      retrySyncAfterDelay();
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Issue 8: Modern clipboard API with fallback to deprecated execCommand
async function copyToClipboard(text) {
  try {
    if (navigator.clipboard && window.isSecureContext) {
      await navigator.clipboard.writeText(text);
      return;
    }
  } catch (err) {
    console.warn("Clipboard API failed, falling back to execCommand:", err);
  }
  
  // Fallback to deprecated execCommand for older browsers or insecure contexts
  const ta = document.createElement("textarea");
  ta.value = text;
  document.body.appendChild(ta);
  ta.select();
  document.execCommand("copy");
  document.body.removeChild(ta);
}

// Issue 10: Sync status indicator functions
function updateSyncStatus(status, message) {
  const statusDot = document.getElementById("status-dot");
  const statusText = document.getElementById("status-text");
  
  if (!statusDot || !statusText) return; // Elements might not exist yet
  
  // Clear existing status classes
  statusDot.classList.remove("sync-success", "sync-progress", "sync-error");
  
  switch (status) {
    case "success":
      statusDot.classList.add("sync-success");
      statusText.textContent = message || "Synced";
      syncRetryCount = 0; // Reset retry count on success
      break;
    case "progress":
      statusDot.classList.add("sync-progress");
      statusText.textContent = message || "Syncing...";
      break;
    case "error":
      statusDot.classList.add("sync-error");
      statusText.textContent = message || "Sync failed";
      break;
    default:
      statusText.textContent = message || "";
  }
}

function retrySyncAfterDelay() {
  if (syncRetryCount >= MAX_SYNC_RETRIES) {
    updateSyncStatus("error", "Sync failed â€” max retries exceeded");
    return;
  }
  
  syncRetryCount++;
  updateSyncStatus("error", `Sync failed â€” retrying in 5s (${syncRetryCount}/${MAX_SYNC_RETRIES})`);
  
  if (syncRetryTimeout) {
    clearTimeout(syncRetryTimeout);
  }
  
  syncRetryTimeout = setTimeout(async () => {
    updateSyncStatus("progress", "Retrying sync...");
    
    // Trigger auto-sync retry
    parent.postMessage({ pluginMessage: { type: "sync-to-sheet", isAutoSync: true } }, "*");
  }, 5000);
}

function escHtml(str) {
  if (!str) return "";
  return str.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;").replace(/"/g,"&quot;");
}

function showToast(msg, isError) {
  const t = document.getElementById("toast");
  t.textContent = msg;
  t.className = "toast" + (isError ? " error" : "");
  setTimeout(() => t.classList.add("show"), 10);
  setTimeout(() => t.classList.remove("show"), 2500);
}

function showLoading(text = "Loading...") {
  const overlay = document.getElementById("loading-overlay");
  const loadingText = document.getElementById("loading-text");
  loadingText.textContent = text;
  overlay.classList.add("show");
}

function hideLoading() {
  const overlay = document.getElementById("loading-overlay");
  overlay.classList.remove("show");
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// SETTINGS â€” API URL & Taxonomy Management
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// UNDO / REDO
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const undoStack = [];
const redoStack = [];
const MAX_UNDO = 50;

function pushUndo(action) {
  // action: { type, nodeId, oldData, newData, description }
  undoStack.push(action);
  if (undoStack.length > MAX_UNDO) undoStack.shift();
  redoStack.length = 0; // Clear redo on new action
  updateUndoRedoButtons();
}

function updateUndoRedoButtons() {
  const undoBtn = document.getElementById("undo-btn");
  const redoBtn = document.getElementById("redo-btn");
  undoBtn.disabled = undoStack.length === 0;
  undoBtn.style.opacity = undoStack.length === 0 ? "0.4" : "1";
  undoBtn.style.color = undoStack.length === 0 ? "var(--text-muted)" : "var(--text)";
  undoBtn.title = undoStack.length > 0 ? `Undo: ${undoStack[undoStack.length - 1].description}` : "Nothing to undo";
  redoBtn.disabled = redoStack.length === 0;
  redoBtn.style.opacity = redoStack.length === 0 ? "0.4" : "1";
  redoBtn.style.color = redoStack.length === 0 ? "var(--text-muted)" : "var(--text)";
  redoBtn.title = redoStack.length > 0 ? `Redo: ${redoStack[redoStack.length - 1].description}` : "Nothing to redo";
}

document.getElementById("undo-btn").addEventListener("click", () => {
  if (undoStack.length === 0) return;
  const action = undoStack.pop();
  redoStack.push(action);
  applyUndoRedo(action, "undo");
  updateUndoRedoButtons();
});

document.getElementById("redo-btn").addEventListener("click", () => {
  if (redoStack.length === 0) return;
  const action = redoStack.pop();
  undoStack.push(action);
  applyUndoRedo(action, "redo");
  updateUndoRedoButtons();
});

function applyUndoRedo(action, direction) {
  const data = direction === "undo" ? action.oldData : action.newData;

  if (action.type === "save-tag" || action.type === "clear-tag") {
    if (data) {
      // Restore tag
      parent.postMessage({ pluginMessage: { type: "restore-tag", nodeId: action.nodeId, data: data } }, "*");
    } else {
      // Clear tag
      parent.postMessage({ pluginMessage: { type: "restore-clear-tag", nodeId: action.nodeId } }, "*");
    }
  }

  if (action.type === "set-screen" || action.type === "clear-screen") {
    if (data) {
      parent.postMessage({ pluginMessage: { type: "restore-screen", nodeId: action.nodeId, screenName: data } }, "*");
    } else {
      parent.postMessage({ pluginMessage: { type: "restore-clear-screen", nodeId: action.nodeId } }, "*");
    }
  }

  const label = direction === "undo" ? "Undid" : "Redid";
  showToast(`${label}: ${action.description}`);
}

// Keyboard shortcut: Ctrl+Z / Ctrl+Shift+Z
document.addEventListener("keydown", (e) => {
  if ((e.ctrlKey || e.metaKey) && e.key === "z" && !e.shiftKey) {
    e.preventDefault();
    document.getElementById("undo-btn").click();
  }
  if ((e.ctrlKey || e.metaKey) && ((e.key === "z" && e.shiftKey) || e.key === "y")) {
    e.preventDefault();
    document.getElementById("redo-btn").click();
  }
});

let apiUrl = null;
let apiToken = null;
let isAdminMode = false;
const ADMIN_PASSWORD = "tallo2024";

// Issue 5: Track pending changes to batch with sync calls
let pendingChanges = [];

// Issue 10: Sync status tracking and retry mechanism
let syncRetryCount = 0;
const MAX_SYNC_RETRIES = 3;
let syncRetryTimeout = null;
let taxonomyData = null;
let figmaFileKey = null;
let customScreensList = []; // Track which screens are custom
let autoSyncTimeout = null; // Debounce timer for auto-sync

// Save Figma file URL and extract fileKey
document.getElementById("save-figma-url-btn").addEventListener("click", () => {
  const url = document.getElementById("figma-url-input").value.trim();
  if (!url) {
    showToast("Please enter a Figma file URL", true);
    return;
  }
  
  // Extract fileKey from various Figma URL formats
  // Examples:
  // https://www.figma.com/design/Vh8DowDkYMODh6EReLLKQY/...
  // https://www.figma.com/file/Vh8DowDkYMODh6EReLLKQY/...
  const match = url.match(/figma\.com\/(design|file)\/([a-zA-Z0-9]+)/);
  
  if (!match) {
    showToast("Invalid Figma URL format", true);
    return;
  }
  
  figmaFileKey = match[2];
  parent.postMessage({ pluginMessage: { type: "save-figma-filekey", fileKey: figmaFileKey } }, "*");
  
  const statusEl = document.getElementById("figma-url-status");
  statusEl.style.display = "block";
  statusEl.style.background = "var(--cat-nav-dim)";
  statusEl.style.color = "var(--cat-nav)";
  statusEl.textContent = `âœ… File key saved: ${figmaFileKey}`;
  
  showToast("File key saved!");
});

// Save API URL and token to plugin storage
document.getElementById("save-api-url-btn").addEventListener("click", async () => {
  const url = document.getElementById("api-url-input").value.trim();
  const token = document.getElementById("api-token-input").value.trim();
  
  if (!url) {
    showToast("Please enter an API URL", true);
    return;
  }
  
  if (!token) {
    showToast("Please enter an API token", true);
    return;
  }
  
  // Validate URL format
  if (!url.startsWith("https://script.google.com/")) {
    showToast("URL must be a Google Apps Script URL", true);
    return;
  }
  
  apiUrl = url;
  apiToken = token;
  parent.postMessage({ pluginMessage: { type: "save-api-url", url, token } }, "*");
  showToast("Saving API URL and token...");
  
  // Try to load taxonomy
  await loadTaxonomyFromAPI();
});

// Refresh taxonomy button
document.getElementById("refresh-taxonomy-btn").addEventListener("click", async () => {
  if (!apiUrl) {
    showToast("Please configure API URL first", true);
    return;
  }
  await loadTaxonomyFromAPI();
});

// Load API URL from storage on init
async function loadAPIUrlFromStorage() {
  parent.postMessage({ pluginMessage: { type: "get-api-url" } }, "*");
}

// Load Figma fileKey from storage on init
async function loadFileKeyFromStorage() {
  parent.postMessage({ pluginMessage: { type: "get-figma-filekey" } }, "*");
}

// Fetch taxonomy from API
async function loadTaxonomyFromAPI() {
  if (!apiUrl || !apiToken) return;
  
  showLoading("Loading taxonomy from Google Sheets...");
  
  const statusEl = document.getElementById("api-status");
  statusEl.style.display = "block";
  statusEl.style.background = "var(--accent-dim)";
  statusEl.style.color = "var(--accent)";
  statusEl.textContent = "â³ Loading taxonomy from Google Sheets...";
  
  try {
    const response = await fetch(apiUrl + "?action=getTaxonomy&token=" + encodeURIComponent(apiToken));
    if (!response.ok) throw new Error("Failed to fetch: " + response.status);
    
    const data = await response.json();
    if (data.error) throw new Error(data.error);
    
    taxonomyData = data;
    
    // Track custom screens separately
    if (data.customScreens && Array.isArray(data.customScreens)) {
      customScreensList = data.customScreens.filter(s => typeof s === 'string' && s.trim());
    }
    
    // Replace with sheet data (clear hardcoded fallback when API is connected)
    if (data.screens) {
      SCREENS.length = 0;
      const validScreens = data.screens.filter(s => {
        // Handle both object format { name, category } and old string format
        if (typeof s === 'object' && s !== null && s.name && typeof s.name === 'string') {
          return s.name.trim();
        } else if (typeof s === 'string') {
          return s.trim();
        }
        return false;
      }).map(s => {
        // Normalize to object format
        if (typeof s === 'object' && s !== null && s.name) {
          return {
            name: s.name,
            category: s.category || "Other"
          };
        } else if (typeof s === 'string') {
          return { name: s, category: "Other" };
        }
        return null;
      }).filter(s => s !== null);
      SCREENS.push(...validScreens);
    }
    
    if (data.events) {
      EVENTS.length = 0;
      const validEvents = data.events.filter(e => e && typeof e.event === 'string' && e.event.trim());
      EVENTS.push(...validEvents);
      // Rebuild categories from loaded events
      CATEGORIES = [...new Set(EVENTS.map(e => e.cat).filter(Boolean))];
    }
    
    if (data.propertyTypes && Object.keys(data.propertyTypes).length > 0) {
      // Merge with existing PROPERTY_TYPES
      Object.assign(PROPERTY_TYPES, data.propertyTypes);
    }
    
    // Re-populate dropdowns
    init();
    
    // Update UI
    updateTaxonomyStatus();
    updateCustomEntriesList();
    
    statusEl.style.background = "var(--accent)";
    statusEl.style.color = "#0a0a1a";
    statusEl.textContent = "âœ… Taxonomy loaded successfully!";
    setTimeout(() => { statusEl.style.display = "none"; }, 3000);
    
    hideLoading();
    showToast("Taxonomy loaded from Google Sheets!");
    
    // Auto-cleanup orphaned screen frame assignments
    // If a screen assignment references a name not in the current taxonomy, remove it
    cleanupOrphanedScreenFrames();
    
  } catch (err) {
    hideLoading();
    statusEl.style.background = "var(--danger-dim)";
    statusEl.style.color = "var(--danger)";
    statusEl.textContent = "âŒ Failed to load: " + err.message;
    showToast("Failed to load taxonomy: " + err.message, true);
  }
}

// Update taxonomy status display
function updateTaxonomyStatus() {
  document.getElementById("taxonomy-screens-count").textContent = SCREENS.length;
  document.getElementById("taxonomy-events-count").textContent = EVENTS.length;
  
  if (taxonomyData) {
    document.getElementById("taxonomy-custom-screens-count").textContent = 
      taxonomyData.customScreens ? taxonomyData.customScreens.length : 0;
    document.getElementById("taxonomy-custom-events-count").textContent = 
      taxonomyData.customEvents ? taxonomyData.customEvents.length : 0;
    document.getElementById("taxonomy-source").textContent = 
      "Loaded from Google Sheets (" + new Date().toLocaleString() + ")";
  } else {
    document.getElementById("taxonomy-custom-screens-count").textContent = "0";
    document.getElementById("taxonomy-custom-events-count").textContent = "0";
    document.getElementById("taxonomy-source").textContent = "Using hardcoded data (fallback)";
  }
}

// Update custom entries list
function updateCustomEntriesList() {
  const list = document.getElementById("custom-entries-list");
  
  if (!taxonomyData || 
      (!taxonomyData.customScreens?.length && !taxonomyData.customEvents?.length)) {
    list.innerHTML = `
      <div class="empty-state" style="padding:20px;">
        <div class="icon" style="font-size:24px;">ğŸ“</div>
        <p style="font-size:11px;">No custom entries yet. Add custom screens or events from the Tag tab.</p>
      </div>
    `;
    return;
  }
  
  list.innerHTML = "";
  
  // Custom screens
  if (taxonomyData.customScreens && taxonomyData.customScreens.length > 0) {
    const screensHeader = document.createElement("div");
    screensHeader.style.cssText = "font-size:11px;font-weight:600;margin-bottom:6px;color:var(--text-muted);";
    screensHeader.textContent = "Custom Screens";
    list.appendChild(screensHeader);
    
    taxonomyData.customScreens.forEach(screen => {
      const item = createCustomEntryItem("screen", screen);
      list.appendChild(item);
    });
  }
  
  // Custom events
  if (taxonomyData.customEvents && taxonomyData.customEvents.length > 0) {
    const eventsHeader = document.createElement("div");
    eventsHeader.style.cssText = "font-size:11px;font-weight:600;margin:12px 0 6px;color:var(--text-muted);";
    eventsHeader.textContent = "Custom Events";
    list.appendChild(eventsHeader);
    
    taxonomyData.customEvents.forEach(event => {
      const item = createCustomEntryItem("event", event.event, event);
      list.appendChild(item);
    });
  }
}

function createCustomEntryItem(type, name, data) {
  const item = document.createElement("div");
  item.className = "audit-item";
  item.style.marginBottom = "6px";
  
  const info = document.createElement("div");
  info.className = "audit-info";
  info.style.flex = "1";
  
  const nameEl = document.createElement("div");
  nameEl.style.cssText = "font-weight:600;font-size:11px;";
  nameEl.textContent = name;
  info.appendChild(nameEl);
  
  if (type === "event" && data) {
    const catEl = document.createElement("div");
    catEl.style.cssText = "font-size:10px;color:var(--accent);";
    catEl.textContent = data.cat || "Custom";
    info.appendChild(catEl);
    
    if (data.desc) {
      const descEl = document.createElement("div");
      descEl.style.cssText = "font-size:10px;color:var(--text-muted);";
      descEl.textContent = data.desc;
      info.appendChild(descEl);
    }
  }
  
  item.appendChild(info);
  
  const deleteBtn = document.createElement("button");
  deleteBtn.className = "btn btn-danger btn-sm";
  deleteBtn.textContent = "Delete";
  deleteBtn.style.flex = "none";
  deleteBtn.style.width = "60px";
  deleteBtn.addEventListener("click", async (e) => {
    e.stopPropagation();
    await deleteCustomEntry(type, name);
  });
  
  item.appendChild(deleteBtn);
  
  return item;
}

async function deleteCustomEntry(type, name) {
  if (!apiUrl) {
    showToast("API URL not configured", true);
    return;
  }
  
  if (!confirm(`Delete custom ${type}: "${name}"?`)) return;
  
  showLoading(`Deleting custom ${type}...`);
  
  try {
    const response = await fetch(apiUrl, {
      method: "POST",
      body: JSON.stringify({
        action: "deleteCustom",
        token: apiToken,
        type: type,
        name: name
      })
    });
    
    const result = await response.json();
    if (!result.success) throw new Error(result.error || "Failed to delete");
    
    showToast(`Custom ${type} deleted`);
    await loadTaxonomyFromAPI();
    hideLoading();
    
  } catch (err) {
    hideLoading();
    showToast("Failed to delete: " + err.message, true);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ADMIN MODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function promptAdminPassword() {
  const modal = document.getElementById("admin-password-modal");
  const input = document.getElementById("admin-password-input");
  const errorEl = document.getElementById("admin-password-error");
  const defaultView = document.getElementById("settings-default-view");
  
  // Show modal, hide default view
  defaultView.style.display = "none";
  modal.style.display = "block";
  errorEl.style.display = "none";
  input.value = "";
  setTimeout(() => input.focus(), 50);
}

document.getElementById("admin-password-submit").addEventListener("click", () => {
  const input = document.getElementById("admin-password-input");
  const errorEl = document.getElementById("admin-password-error");
  const modal = document.getElementById("admin-password-modal");
  
  if (input.value === ADMIN_PASSWORD) {
    modal.style.display = "none";
    isAdminMode = true;
    updateSettingsView();
    showToast("ğŸ”“ Admin mode unlocked");
  } else {
    errorEl.style.display = "block";
    input.value = "";
    input.focus();
  }
});

document.getElementById("admin-password-cancel").addEventListener("click", () => {
  document.getElementById("admin-password-modal").style.display = "none";
  document.getElementById("settings-default-view").style.display = "block";
});

document.getElementById("admin-password-input").addEventListener("keydown", (e) => {
  if (e.key === "Enter") document.getElementById("admin-password-submit").click();
  if (e.key === "Escape") document.getElementById("admin-password-cancel").click();
});

function updateSettingsView() {
  const defaultView = document.getElementById("settings-default-view");
  const adminView = document.getElementById("settings-admin-view");
  const toggleBtn = document.getElementById("admin-toggle-btn");
  const configuredView = document.getElementById("settings-configured-view");
  const unconfiguredView = document.getElementById("settings-unconfigured-view");
  
  if (isAdminMode) {
    defaultView.style.display = "none";
    adminView.style.display = "block";
    toggleBtn.textContent = "ğŸ”“";
    toggleBtn.style.color = "var(--accent)";
    toggleBtn.style.borderColor = "var(--accent)";
    toggleBtn.title = "Admin mode active";
  } else {
    defaultView.style.display = "block";
    adminView.style.display = "none";
    toggleBtn.textContent = "ğŸ”’";
    toggleBtn.style.color = "var(--text-muted)";
    toggleBtn.style.borderColor = "var(--border)";
    toggleBtn.title = "Toggle admin mode";
    
    // Show configured or unconfigured view
    const isConfigured = apiUrl && apiToken;
    configuredView.style.display = isConfigured ? "block" : "none";
    unconfiguredView.style.display = isConfigured ? "none" : "block";
    
    // Update summary line
    document.getElementById("taxonomy-summary-default").textContent =
      SCREENS.length + " screens, " + EVENTS.length + " events loaded";
  }
}

// Admin toggle button (lock icon in header)
document.getElementById("admin-toggle-btn").addEventListener("click", () => {
  if (isAdminMode) {
    isAdminMode = false;
    updateSettingsView();
    showToast("ğŸ”’ Admin mode locked");
  } else {
    promptAdminPassword();
  }
});

// Admin unlock buttons (at bottom of default views)
document.getElementById("admin-unlock-btn").addEventListener("click", () => {
  promptAdminPassword();
});
document.getElementById("admin-unlock-btn-unconfigured").addEventListener("click", () => {
  promptAdminPassword();
});

// Non-admin refresh taxonomy button
document.getElementById("refresh-taxonomy-default-btn").addEventListener("click", async () => {
  if (!apiUrl) {
    showToast("Not configured â€” ask your admin", true);
    return;
  }
  await loadTaxonomyFromAPI();
});

// Setup guide link
document.getElementById("setup-guide-link").addEventListener("click", (e) => {
  e.preventDefault();
  showToast("Check SHEET_SETUP.md in the plugin folder");
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// CUSTOM ENTRIES â€” Add/Delete Modal
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let customEntryType = null;
let customEntryData = null;

// Add custom screen button
document.getElementById("add-custom-screen-btn").addEventListener("click", () => {
  openCustomEntryModal("screen");
});

// Add custom event button
document.getElementById("add-custom-event-btn").addEventListener("click", () => {
  openCustomEntryModal("event");
});

function openCustomEntryModal(type) {
  customEntryType = type;
  const modal = document.getElementById("custom-entry-modal");
  const title = document.getElementById("modal-title");
  const content = document.getElementById("modal-content");
  
  if (type === "screen") {
    title.textContent = "Add Custom Screen";
    content.innerHTML = `
      <div class="field">
        <label>Screen Name</label>
        <input type="text" id="custom-screen-name" placeholder="e.g. my_feature__my_screen" />
        <div style="font-size:10px;color:var(--text-muted);margin-top:4px;">
          Use format: feature__screen (e.g., settings__notifications)
        </div>
      </div>
    `;
  } else if (type === "event") {
    title.textContent = "Add Custom Event";
    content.innerHTML = `
      <div class="field">
        <label>Event Name</label>
        <input type="text" id="custom-event-name" placeholder="e.g. my_button_clicked" />
      </div>
      <div class="field">
        <label>Category</label>
        <select id="custom-event-category">
          <option value="Custom">Custom</option>
          ${CATEGORIES.map(cat => `<option value="${escHtml(cat)}">${escHtml(cat)}</option>`).join("")}
        </select>
      </div>
      <div class="field">
        <label>Description (optional)</label>
        <input type="text" id="custom-event-desc" placeholder="e.g. User tapped custom button" />
      </div>
      <div class="field">
        <label>Suggested Props (optional, comma-separated)</label>
        <input type="text" id="custom-event-props" placeholder="e.g. button_id,is_active" />
      </div>
    `;
  }
  
  modal.style.display = "block";
  
  // Focus first input
  setTimeout(() => {
    const firstInput = content.querySelector("input");
    if (firstInput) firstInput.focus();
  }, 100);
}

// Modal close
document.getElementById("modal-close-btn").addEventListener("click", closeCustomEntryModal);
document.getElementById("modal-cancel-btn").addEventListener("click", closeCustomEntryModal);

function closeCustomEntryModal() {
  document.getElementById("custom-entry-modal").style.display = "none";
  customEntryType = null;
  customEntryData = null;
}

// Modal save
document.getElementById("modal-save-btn").addEventListener("click", async () => {
  if (customEntryType === "screen") {
    await saveCustomScreen();
  } else if (customEntryType === "event") {
    await saveCustomEvent();
  }
});

async function saveCustomScreen() {
  const name = document.getElementById("custom-screen-name").value.trim();
  
  if (!name) {
    showToast("Please enter a screen name", true);
    return;
  }
  
  // Issue 7: Validate screen_name format (feature__area)
  const screenNamePattern = /^[a-z][a-z0-9_]*__[a-z][a-z0-9_]*$/;
  if (!screenNamePattern.test(name)) {
    showToast("Screen name must follow format: feature__area (lowercase, numbers, underscores)", true);
    return;
  }
  
  // Check if already exists
  const screenExists = SCREENS.some(s => {
    const screenName = typeof s === 'object' ? s.name : s;
    return screenName === name;
  });
  
  if (screenExists) {
    showToast("Screen already exists", true);
    return;
  }
  
  if (!apiUrl) {
    showToast("Please configure API URL in Settings first", true);
    return;
  }
  
  showLoading("Saving custom screen...");
  
  try {
    const response = await fetch(apiUrl, {
      method: "POST",
      body: JSON.stringify({
        action: "addCustom",
        token: apiToken,
        type: "screen",
        name: name
      })
    });
    
    const result = await response.json();
    if (!result.success) throw new Error(result.error || "Failed to save");
    
    // Add to local data as an object with Custom category
    SCREENS.push({ name: name, category: "Custom", isCustom: true });
    customScreensList.push(name); // Track as custom screen
    init(); // Re-populate dropdowns
    
    // Select the new screen in screen frame dropdown
    const screenFrameSel = document.getElementById("screen-frame-select");
    if (screenFrameSel) {
      screenFrameSel.value = name;
    }
    
    showToast("Custom screen added!");
    closeCustomEntryModal();
    
    // Update taxonomy status counts
    updateTaxonomyStatus();
    updateCustomEntriesList();
    
    hideLoading();
    
  } catch (err) {
    hideLoading();
    showToast("Failed to save: " + err.message, true);
  }
}

async function saveCustomEvent() {
  const name = document.getElementById("custom-event-name").value.trim();
  const category = document.getElementById("custom-event-category").value;
  const description = document.getElementById("custom-event-desc").value.trim();
  const propsInput = document.getElementById("custom-event-props").value.trim();
  const props = propsInput ? propsInput.split(",").map(p => p.trim()).filter(p => p) : [];
  
  if (!name) {
    showToast("Please enter an event name", true);
    return;
  }
  
  // Check if already exists
  if (EVENTS.find(e => e.event === name)) {
    showToast("Event already exists", true);
    return;
  }
  
  if (!apiUrl) {
    showToast("Please configure API URL in Settings first", true);
    return;
  }
  
  showLoading("Saving custom event...");
  
  try {
    const response = await fetch(apiUrl, {
      method: "POST",
      body: JSON.stringify({
        action: "addCustom",
        token: apiToken,
        type: "event",
        name: name,
        category: category,
        description: description,
        props: props
      })
    });
    
    const result = await response.json();
    if (!result.success) throw new Error(result.error || "Failed to save");
    
    // Add to local data
    const newEvent = {
      event: name,
      cat: category,
      desc: description,
      props: props,
      isCustom: true
    };
    EVENTS.push(newEvent);
    
    // Add to categories if needed
    if (!CATEGORIES.includes(category)) {
      CATEGORIES.push(category);
    }
    
    init(); // Re-populate dropdowns
    
    // Select the new event
    document.getElementById("event-select").value = name;
    showEventDescription(newEvent);
    showSuggestedProps(name);
    
    showToast("Custom event added!");
    closeCustomEntryModal();
    
    // Update taxonomy status counts
    updateTaxonomyStatus();
    updateCustomEntriesList();
    
    hideLoading();
    
  } catch (err) {
    hideLoading();
    showToast("Failed to save: " + err.message, true);
  }
}

// Close modal on outside click
document.getElementById("custom-entry-modal").addEventListener("click", (e) => {
  if (e.target.id === "custom-entry-modal") {
    closeCustomEntryModal();
  }
});

// â•â•â• Boot â•â•â•
init();
loadAPIUrlFromStorage();
loadFileKeyFromStorage();
updateTaxonomyStatus();
updateSettingsView();

// Issue 10: Initialize sync status
updateSyncStatus("", "Not synced");
</script>
</body>
</html>
